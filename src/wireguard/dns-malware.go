/*
 * Copyright (c) 2022 DuckDuckGo
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

// #include <android/log.h>
import "C"

import (
    "fmt"
    "strings"

    "github.com/miekg/dns"
)


// parseDNSResponse parses the raw DNS response from a byte slice.
func parseDNSResponse(data []byte) *dns.Msg {
    tag := cstring("WireGuard/GoBackend/parseDNSResponse")
    // Create a new DNS message structure
    dnsMsg := new(dns.Msg)

    // Unpack the DNS message from the raw data
    err := dnsMsg.Unpack(data)
    if err != nil {
        C.__android_log_write(C.ANDROID_LOG_DEBUG, tag, cstring(fmt.Sprintf("Failed to unpack DNS message: %v", err)))
        return nil
    }

    // Check if this is a DNS response (QR bit set)
    if dnsMsg.Response {
        return dnsMsg
    }

    // If not a response, return nil
    return nil
}


/*
 * WasDNSMalwareBlocked checks if the DNS packet contains a "blocked:m" TXT
 * record under the "explanation.invalid" domain. If such a record is found,
 * it returns true along with the domain being blocked.
 * That record is found when our the DDG (malware) DNS server blocks domains that
 * serve malware
 */
func WasDNSMalwareBlocked(dnsData []byte) (bool, string) {
    dnsResponse := parseDNSResponse(dnsData)
    if dnsResponse == nil {
        return false, ""
    }

    // Look for "explanation.invalid" in the additional section
    for _, rr := range dnsResponse.Extra {
        if txtRecord, ok := rr.(*dns.TXT); ok {
            if txtRecord.Hdr.Name == "explanation.invalid." {
                for _, txt := range txtRecord.Txt {
                    if txt == "blocked:m" {
                        // If there is a matching TXT record, return the blocked domain
                        if len(dnsResponse.Question) > 0 {
                            blockedDomain := dnsResponse.Question[0].Name
                            // remove the trailing dot (FQDN) if present
                            blockedDomain = strings.TrimSuffix(blockedDomain, ".")
                            return true, blockedDomain
                        }
                    }
                }
            }
        }
    }

    return false, ""
}